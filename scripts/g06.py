# -*- coding: utf-8 -*-
"""Another copy of 2rev_Propuesta Conceptual - G06.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BgSeQNF3v41ATp_wB0WtVLszKrwAd6_V
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import fsspec
import geopandas as gpd
import requests
import os
import seaborn as sns

df = pd.read_csv('database.csv')
# Procesamiento de fechas
df['Date'] = pd.to_datetime(df['Date'], format='mixed', utc=True)
df['Year'] = df['Date'].apply(lambda x: x.year)

df.info()

df['Magnitude Source'].unique()

df['Status'].unique()

tipos_magnitud_mw = ['MW', 'MWC', 'MWB', 'MWW', 'MWR']

# Filtramos
df_mw_family = df[df['Magnitude Type'].isin(tipos_magnitud_mw)].copy()

df_mw_family

"""## Histogranma"""

"""## Histograma de magnitudes"""

fig, ax = plt.subplots(1, 1, figsize=(12, 5))

# Histograma con color y bordes definidos
color_hist = 'skyblue'
edge_color = 'black'
ax.hist(df_mw_family['Magnitude'].dropna(), bins=20, color=color_hist, edgecolor=edge_color)

# Títulos y etiquetas con mayor claridad
ax.set_title('Distribución de magnitud de terremotos (1965-2016)', fontsize=16)
ax.set_xlabel('Magnitud (Mw)', fontsize=14)
ax.set_ylabel('Frecuencia de eventos', fontsize=14)
ax.grid(False)  # Removemos la cuadrícula

# Ajuste del rango del eje X
ax.set_xlim(5, 9)

# Señalar la zona de interés: magnitud 7
ax.axvline(x=7, color='red', linestyle='--', linewidth=2, label='Umbral magnitud 7')
ax.legend(fontsize=12)

plt.show()

# Segundo histograma
plt.figure(figsize=(12, 5))

# Histograma con curva KDE
sns.set_style("white")  # Cambiamos de "whitegrid" a "white"
ax = sns.histplot(
    data=df_mw_family,
    x='Magnitude',
    kde=True,
    bins=20,
    edgecolor='black'
)

ax.set_title('Distribución de la magnitud de 23,412 eventos sísmicos (1965–2016, fuente: USGS)', fontsize=16)
ax.set_xlabel('Magnitud (Mw)', fontsize=14)
ax.set_ylabel('Frecuencia de eventos', fontsize=14)
ax.set_xlim(5, 9)
ax.grid(False)  # Removemos la cuadrícula

ax.axvline(x=7, color='red', linestyle='--', linewidth=2, label='Umbral magnitud 7')
ax.legend(fontsize=12)

plt.show()

"""## Correlacion de variables de sismos"""

import matplotlib.pyplot as plt
import seaborn as sns

fig, ax = plt.subplots(figsize=(12, 6))

# Gráfico de dispersión
sns.scatterplot(data=df_mw_family, x='Magnitude', y='Depth', alpha=1, color='steelblue', ax=ax)

# Añadimos líneas de referencia para clasificar la profundidad
# Línea que separa eventos superficiales de intermedios a 70 km
ax.axhline(y=70, color='red', linestyle='--', linewidth=1.5, label='Límite 70 km')

# Línea que separa eventos intermedios de profundos a 300 km
ax.axhline(y=300, color='green', linestyle='--', linewidth=1.5, label='Límite 300 km')

# Opcional: invertir el eje Y para que las profundidades menores (más superficiales) se muestren en la parte superior
ax.invert_yaxis()

# Configuramos los títulos y etiquetas
#ax.set_title('Relación entre Magnitud y Profundidad (Magnitudes MW)', fontsize=14)
ax.set_xlabel('Magnitud', fontsize=12)
ax.set_ylabel('Profundidad (km)', fontsize=12)

# Mostramos la leyenda y el gráfico
ax.legend()
plt.show()

"""## Evolución de sismos"""

"""## Cantidad de sismos por año"""

# Agrupamos por año y contamos
sismos_por_anio = df.groupby('Year').size()

plt.figure(figsize=(15, 8))

# Gráfico principal
plt.plot(sismos_por_anio.index, sismos_por_anio.values,
         marker='o',
         linestyle='-',
         linewidth=2,
         markersize=8,
         color='#2E86C1',
         markerfacecolor='white',
         markeredgewidth=2)

# Línea de tendencia
z = np.polyfit(range(len(sismos_por_anio)), sismos_por_anio.values, 1)
p = np.poly1d(z)
plt.plot(sismos_por_anio.index, p(range(len(sismos_por_anio))),
         "r--", alpha=0.8,
         label='Tendencia')

plt.title('Evolución de la cantidad de sismos por año',
          fontsize=16,
          pad=20)
plt.xlabel('Año', fontsize=12)
plt.ylabel('Cantidad de sismos', fontsize=12)

plt.xticks(rotation=45)

# Anotaciones de máximo y mínimo
max_year = sismos_por_anio.idxmax()
min_year = sismos_por_anio.idxmin()

plt.annotate(f'Máximo: {sismos_por_anio[max_year]} sismos',
            xy=(max_year, sismos_por_anio[max_year]),
            xytext=(10, 10),
            textcoords='offset points',
            ha='left',
            va='bottom',
            bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))

plt.annotate(f'Mínimo: {sismos_por_anio[min_year]} sismos',
            xy=(min_year, sismos_por_anio[min_year]),
            xytext=(10, -10),
            textcoords='offset points',
            ha='left',
            va='top',
            bbox=dict(boxstyle='round,pad=0.5', fc='yellow', alpha=0.5),
            arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))

plt.legend(['Sismos por año', 'Tendencia'], loc='upper left')
plt.tight_layout()
plt.show()

print(f"\nEstadísticas principales:")
print(f"Año con más sismos: {max_year} ({sismos_por_anio[max_year]} sismos)")
print(f"Año con menos sismos: {min_year} ({sismos_por_anio[min_year]} sismos)")
print(f"Promedio anual de sismos: {sismos_por_anio.mean():.1f}")

"""## Grafico Animado y Geoespacial"""

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import matplotlib.pyplot as plt # visualization library

from plotly.offline import init_notebook_mode, plot, iplot
import plotly as py
init_notebook_mode(connected=True)
import plotly.graph_objs as go # plotly graphical object
# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory
import warnings
warnings.filterwarnings("ignore")
import os

# Crear clasificaciones de magnitud
bins = [-float('inf'), 3.5, 5.0, 6.0, 7.0, 8.0, float('inf')]
labels = [
    'Micro o menor',
    'Leve',
    'Moderado',
    'Fuerte',
    'Mayor / Devastador',
    'Catastrófico / Megaterremoto'
]

# Asignar la clasificación
df['clasificacion'] = pd.cut(df['Magnitude'], bins=bins, labels=labels, right=False)


df.columns = df.columns.str.lower()

dataset = df[['latitude','longitude','year','clasificacion','magnitude']].copy()

dataset.info()

dataset.year.value_counts()

len(dataset)

import plotly.graph_objects as go
import pandas as pd

# Asegúrate de tener el dataset cargado correctamente
# Por ejemplo: dataset = pd.read_csv("ruta/dataset.csv")

# Convertir columna 'year' a string para los sliders
dataset['year'] = dataset['year'].astype(str)

# Colores personalizados
custom_colors = {
    'Micro o menor': 'rgb(150, 150, 150)',       # Gris oscuro (más contraste)
    'Leve': 'rgb(0, 176, 240)',                  # Azul brillante
    'Moderado': 'rgb(0, 255, 100)',              # Verde fosforescente
    'Fuerte': 'rgb(255, 221, 0)',                # Amarillo brillante
    'Mayor / Devastador': 'rgb(255, 0, 0)',      # Rojo puro
    'Catastrófico / Megaterremoto': 'rgb(128, 0, 255)'  # Morado intenso
}

types = list(custom_colors.keys())
years = sorted(dataset['year'].unique())

# Frame base (año inicial)
initial_year = years[0]
initial_df = dataset[dataset['year'] == initial_year]

fig = go.Figure()

# Agregar trazas iniciales por tipo
for ty in types:
    df_ty = initial_df[initial_df['clasificacion'] == ty]
    fig.add_trace(go.Scattergeo(
        lon = df_ty['longitude'],
        lat = df_ty['latitude'],
        mode = 'markers',
        name = ty,
        text = df_ty['magnitude'].astype(str) + ' Mw',
        marker = dict(
            size = 8,
            color = custom_colors[ty],
            line = dict(width=0.5, color='white'),
            opacity = 0.7
        )
    ))

# Crear frames por año
frames = []
for year in years:
    frame_data = []
    df_year = dataset[dataset['year'] == year]
    for ty in types:
        df_ty = df_year[df_year['clasificacion'] == ty]
        frame_data.append(go.Scattergeo(
            lon = df_ty['longitude'],
            lat = df_ty['latitude'],
            mode = 'markers',
            name = ty,
            text = df_ty['magnitude'].astype(str) + ' Mw',
            marker = dict(
                size = 8,
                color = custom_colors[ty],
                line = dict(width=0.5, color='white'),
                opacity = 0.7
            )
        ))
    frames.append(go.Frame(data=frame_data, name=year))

fig.frames = frames

# Layout
fig.update_layout(
    title="Sismos por Año y Clasificación",
    geo=dict(
        showframe=False,
        showland=True,
        showcoastlines=True,
        showcountries=True,
        landcolor='rgb(217, 217, 217)',
        lakecolor='white',
        countrycolor='black'
    ),
    legend=dict(
        title="Clasificación",
        x=0.01,
        y=0.98,
        xanchor='left',
        yanchor='top',
        bgcolor='rgba(255,255,255,0.7)',
        bordercolor='black',
        borderwidth=1,
        font=dict(size=12)
    ),
    updatemenus=[dict(
        type="buttons",
        direction="left",
        buttons=[
            dict(label="Play", method="animate", args=[None, {"frame": {"duration": 500, "redraw": False},
                                                              "fromcurrent": True}]),
            dict(label="Pause", method="animate", args=[[None], {"frame": {"duration": 0}, "mode": "immediate"}])
        ],
        pad={"r": 10, "t": 80},
        showactive=False,
        x=0.1,
        y=0,
        xanchor="right",
        yanchor="top"
    )],
    sliders=[dict(
        active=0,
        y=0,
        x=0.1,
        len=0.9,
        pad={"b": 10, "t": 60},
        currentvalue={"prefix": "Año: ", "font": {"size": 16}},
        steps=[dict(method="animate",
                    label=year,
                    args=[[year], {"frame": {"duration": 300, "redraw": False},
                                   "mode": "immediate"}]) for year in years]
    )]
)
# Mostrar animación
from plotly.offline import plot
plot(fig)

plot(fig, filename='sismos_animacion.html', auto_open=True)